#[derive(Debug, Eq, PartialEq)]
#[repr(C)]
pub struct LittleEndianU8 {
    value: u8,
}

impl LittleEndianU8 {
    pub fn value(&self) -> u8 {
        u8::from_le(self.value)
    }
}

#[derive(Debug, Eq, PartialEq)]
#[repr(C)]
pub struct LittleEndianU16 {
    value: u16,
}

impl LittleEndianU16 {
    pub fn value(&self) -> u16 {
        u16::from_le(self.value)
    }

    pub fn decode_string(array: &[LittleEndianU16; 128]) -> String {
        let mut v = Vec::with_capacity(array.len());
        array
            .iter()
            .filter(|ch| ch.value() != 0x00)
            .for_each(|ch| v.push(ch.value()));
        String::from_utf16_lossy(&v)
    }
}

#[derive(Debug, Eq, PartialEq)]
#[repr(C)]
pub struct LittleEndianU32 {
    value: u32,
}

impl LittleEndianU32 {
    pub fn value(&self) -> u32 {
        u32::from_le(self.value)
    }
}

#[cfg(test)]
mod tests {
    use super::{LittleEndianU16, LittleEndianU8};

    #[test]
    fn little_endian_to_native_endian() {
        let int = LittleEndianU8 {
            value: 32u8.to_le(),
        };
        assert_eq!(int.value(), 32u8);
    }

    #[test]
    fn decode_package_name() {
        let bytes: [u8; 256] = [
            0x74, 0x00, 0x65, 0x00, 0x73, 0x00, 0x74, 0x00, 0x2e, 0x00, 0x61, 0x00, 0x70, 0x00,
            0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
        ];
        let ptr = bytes.as_ptr() as *const [LittleEndianU16; 128];
        let utf16_chars = unsafe { &*ptr };
        assert_eq!("test.app", LittleEndianU16::decode_string(utf16_chars));
    }
}
